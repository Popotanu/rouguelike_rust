diff --git a/.vscode/settings.json b/.vscode/settings.json
index 93479bb..8ea9900 100644
--- a/.vscode/settings.json
+++ b/.vscode/settings.json
@@ -1,3 +1,3 @@
 {
-  "cSpell.words": ["Saveload"]
+  "cSpell.words": ["gamelog", "Saveload"]
 }
diff --git a/src/damage_system.rs b/src/damage_system.rs
index 4599e40..ff23ab7 100644
--- a/src/damage_system.rs
+++ b/src/damage_system.rs
@@ -1,4 +1,4 @@
-use super::{CombatStats, Player, SufferDamage};
+use super::{gamelog::GameLog, CombatStats, Name, Player, SufferDamage};
 use rltk::console;
 use specs::prelude::*;
 
@@ -29,12 +29,22 @@ pub fn delete_the_dead(ecs: &mut World) {
     {
         let combat_stats = ecs.read_storage::<CombatStats>();
         let players = ecs.read_storage::<Player>();
+        let names = ecs.read_storage::<Name>();
         let entities = ecs.entities();
+        let mut log = ecs.write_resource::<GameLog>();
+
         for (entity, stats) in (&entities, &combat_stats).join() {
             if stats.hp < 1 {
                 let player = players.get(entity);
+
                 match player {
-                    None => dead.push(entity),
+                    None => {
+                        let victim_name = names.get(entity);
+                        if let Some(victim_name) = victim_name {
+                            log.entries.push(format!("{} collapsed", &victim_name.name));
+                        }
+                        dead.push(entity)
+                    }
                     Some(_) => console::log("You are dead"),
                 }
             }
diff --git a/src/gamelog.rs b/src/gamelog.rs
new file mode 100644
index 0000000..dbe28c0
--- /dev/null
+++ b/src/gamelog.rs
@@ -0,0 +1,3 @@
+pub struct GameLog {
+    pub entries: Vec<String>,
+}
diff --git a/src/gui.rs b/src/gui.rs
new file mode 100644
index 0000000..dbc35e2
--- /dev/null
+++ b/src/gui.rs
@@ -0,0 +1,147 @@
+use super::{gamelog::GameLog, CombatStats, Map, Name, Player, Position};
+use rltk::{Point, Rltk, RGB};
+use specs::prelude::*;
+
+pub fn draw_ui(ecs: &World, ctx: &mut Rltk) {
+    ctx.draw_box(
+        0,
+        43,
+        79,
+        6,
+        RGB::named(rltk::WHITE),
+        RGB::named(rltk::BLACK),
+    );
+
+    let combat_stats = ecs.read_storage::<CombatStats>();
+    let players = ecs.read_storage::<Player>();
+    for (_player, stats) in (&players, &combat_stats).join() {
+        let health = format!(" HP: {} / {}", stats.hp, stats.max_hp);
+        ctx.print_color(
+            12,
+            43,
+            RGB::named(rltk::YELLOW),
+            RGB::named(rltk::BLACK),
+            &health,
+        );
+
+        ctx.draw_bar_horizontal(
+            28,
+            43,
+            51,
+            stats.hp,
+            stats.max_hp,
+            RGB::named(rltk::RED),
+            RGB::named(rltk::BLACK),
+        );
+    }
+
+    let log = ecs.fetch::<GameLog>();
+    let mut y = 44;
+    for s in log.entries.iter().rev() {
+        if y < 49 {
+            ctx.print(2, y, s);
+        }
+        y += 1;
+    }
+
+    // マウスで指してるセルの背景に色つける
+    // mouse_pos.0: x
+    // mouse_pos.1: y
+    let mouse_pos = ctx.mouse_pos();
+    ctx.set_bg(mouse_pos.0, mouse_pos.1, RGB::named(rltk::MAGENTA));
+
+    draw_tooltips(&ecs, ctx);
+}
+
+fn draw_tooltips(ecs: &World, ctx: &mut Rltk) {
+    let map = ecs.fetch::<Map>();
+    let names = ecs.read_storage::<Name>();
+    let positions = ecs.read_storage::<Position>();
+
+    let mouse_pos = ctx.mouse_pos();
+    if mouse_pos.0 >= map.width || mouse_pos.1 >= map.height {
+        return;
+    }
+    let mut tooltip: Vec<String> = Vec::new();
+
+    for (name, position) in (&names, &positions).join() {
+        let idx = map.xy_idx(position.x, position.y);
+        if position.x == mouse_pos.0 && position.y == mouse_pos.1 && map.visible_tiles[idx] {
+            tooltip.push(name.name.to_string());
+        }
+
+        if !tooltip.is_empty() {
+            let mut width: i32 = 0;
+            for s in tooltip.iter() {
+                if width < s.len() as i32 {
+                    width = s.len() as i32;
+                }
+            }
+            width += 3;
+
+            if mouse_pos.0 > 40 {
+                let arrow_pos = Point::new(mouse_pos.0 - 2, mouse_pos.1);
+                let left_x = mouse_pos.0 - width;
+                let mut y = mouse_pos.1;
+                for s in tooltip.iter() {
+                    ctx.print_color(
+                        left_x,
+                        y,
+                        RGB::named(rltk::WHITE),
+                        RGB::named(rltk::GREY),
+                        s,
+                    );
+                    let padding = (width - s.len() as i32) - 1;
+                    for i in 0..padding {
+                        ctx.print_color(
+                            arrow_pos.x - i,
+                            y,
+                            RGB::named(rltk::WHITE),
+                            RGB::named(rltk::GREY),
+                            &" ".to_string(),
+                        );
+                    }
+                    y += 1;
+                }
+                ctx.print_color(
+                    arrow_pos.x,
+                    arrow_pos.y,
+                    RGB::named(rltk::WHITE),
+                    RGB::named(rltk::GREY),
+                    &"->".to_string(),
+                );
+            } else {
+                let arrow_pos = Point::new(mouse_pos.0 + 1, mouse_pos.1);
+                let left_x = mouse_pos.0 + 3;
+                let mut y = mouse_pos.1;
+                for s in tooltip.iter() {
+                    ctx.print_color(
+                        left_x + 1,
+                        y,
+                        RGB::named(rltk::WHITE),
+                        RGB::named(rltk::GREY),
+                        s,
+                    );
+                    let padding = (width - s.len() as i32) - 1;
+                    for i in 0..padding {
+                        ctx.print_color(
+                            arrow_pos.x + 1 + i,
+                            y,
+                            RGB::named(rltk::WHITE),
+                            RGB::named(rltk::GREY),
+                            &" ".to_string(),
+                        );
+                    }
+                    y += 1;
+                }
+                ctx.print_color(
+                    arrow_pos.x,
+                    arrow_pos.y,
+                    RGB::named(rltk::WHITE),
+                    RGB::named(rltk::GREY),
+                    &"<-".to_string(),
+                );
+            }
+        }
+    }
+}
diff --git a/src/main.rs b/src/main.rs
index 368c761..12cfb54 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -21,6 +21,10 @@ mod melee_combat_system;
 use melee_combat_system::MeleeCombatSystem;
 mod damage_system;
 use damage_system::DamageSystem;
+mod gui;
+use gui::*;
+mod gamelog;
+
 
 // 待ち状態(相手のターン) or 自分のターン
 #[derive(PartialEq, Copy, Clone, Debug)]
@@ -99,14 +103,18 @@ impl GameState for State {
                 ctx.set(pos.x, pos.y, render.fg, render.bg, render.glyph)
             }
         }
+
+        draw_ui(&self.ecs, ctx);
     }
 }
 
 fn main() -> rltk::BError {
     use rltk::RltkBuilder;
-    let context = RltkBuilder::simple80x50()
+    let mut context = RltkBuilder::simple80x50()
         .with_title("風来のたぬぽん")
         .build()?;
+    context.with_post_scanlines(true);
+
     let mut gs = State { ecs: World::new() };
     gs.ecs.register::<Position>();
     gs.ecs.register::<Renderable>();
@@ -119,6 +127,9 @@ fn main() -> rltk::BError {
     gs.ecs.register::<SufferDamage>();
     gs.ecs.register::<WantsToMelee>();
     gs.ecs.insert(RunState::PreRun);
+    gs.ecs.insert(gamelog::GameLog {
+        entries: vec!["Welcome to Rusty Roguelike".to_string()],
+    });
 
     let map: Map = Map::new_map_rooms_and_corridors();
     let (player_x, player_y) = map.rooms[0].center();
diff --git a/src/map.rs b/src/map.rs
index 202ceef..12a3086 100644
--- a/src/map.rs
+++ b/src/map.rs
@@ -3,6 +3,10 @@ use rltk::{Algorithm2D, BaseMap, Point, RandomNumberGenerator, Rltk, RGB};
 use specs::prelude::*;
 use std::cmp::{max, min};
 
+const MAPWIDTH: usize = 80;
+const MAPHEIGHT: usize = 43;
+const MAPCOUNT: usize = MAPHEIGHT * MAPWIDTH;
+
 #[derive(PartialEq, Copy, Clone)]
 pub enum TileType {
     Wall,
@@ -58,14 +62,14 @@ impl Map {
     /// This gives a handful of random rooms and corridors joining them together.
     pub fn new_map_rooms_and_corridors() -> Map {
         let mut map = Map {
-            tiles: vec![TileType::Wall; 80 * 50],
+            tiles: vec![TileType::Wall; MAPCOUNT],
             rooms: Vec::new(),
-            width: 80,
-            height: 50,
-            revealed_tiles: vec![false; 80 * 50],
-            visible_tiles: vec![false; 80 * 50],
-            blocked: vec![false; 80 * 50],
-            tile_content: vec![Vec::new(); 80 * 50],
+            width: MAPWIDTH as i32,
+            height: MAPHEIGHT as i32,
+            revealed_tiles: vec![false; MAPCOUNT],
+            visible_tiles: vec![false; MAPCOUNT],
+            blocked: vec![false; MAPCOUNT],
+            tile_content: vec![Vec::new(); MAPCOUNT],
         };
 
         // ↓で作ったお部屋たちを登録してく
@@ -78,8 +82,8 @@ impl Map {
         for _ in 0..MAX_ROOMS {
             let w = rng.range(MIN_SIZE, MAX_SIZE);
             let h = rng.range(MIN_SIZE, MAX_SIZE);
-            let x = rng.roll_dice(1, 80 - w - 1) - 1;
-            let y = rng.roll_dice(1, 50 - h - 1) - 1;
+            let x = rng.roll_dice(1, MAPWIDTH as i32 - w - 1) - 1;
+            let y = rng.roll_dice(1, MAPHEIGHT as i32 - h - 1) - 1;
             let new_room = Rect::new(x, y, w, h);
             let mut ok = true;
 
diff --git a/src/melee_combat_system.rs b/src/melee_combat_system.rs
index 39f2179..be3a32d 100644
--- a/src/melee_combat_system.rs
+++ b/src/melee_combat_system.rs
@@ -1,5 +1,4 @@
-use super::{CombatStats, Name, SufferDamage, WantsToMelee};
-use rltk::console;
+use super::{gamelog::GameLog, CombatStats, Name, SufferDamage, WantsToMelee};
 use specs::prelude::*;
 
 pub struct MeleeCombatSystem {}
@@ -7,6 +6,7 @@ pub struct MeleeCombatSystem {}
 impl<'a> System<'a> for MeleeCombatSystem {
     type SystemData = (
         Entities<'a>,
+        WriteExpect<'a, GameLog>,
         WriteStorage<'a, WantsToMelee>,
         ReadStorage<'a, Name>,
         ReadStorage<'a, CombatStats>,
@@ -14,7 +14,7 @@ impl<'a> System<'a> for MeleeCombatSystem {
     );
 
     fn run(&mut self, data: Self::SystemData) {
-        let (entities, mut wants_melee, names, combat_stats, mut inflict_damage) = data;
+        let (entities, mut log, mut wants_melee, names, combat_stats, mut inflict_damage) = data;
 
         for (_entity, wants_melee, name, stats) in
             (&entities, &wants_melee, &names, &combat_stats).join()
@@ -27,14 +27,14 @@ impl<'a> System<'a> for MeleeCombatSystem {
                     let damage = i32::max(0, stats.power - target_stats.defense);
 
                     if damage == 0 {
-                        console::log(&format!(
+                        log.entries.push(format!(
                             "{} is unable to hurt {}",
                             &name.name, &target_name.name
                         ));
                     } else {
-                        console::log(&format!(
-                            "{} hits {}, for {} hp.",
-                            &name.name, &target_name.name, damage
+                        log.entries.push(format!(
+                            "{} did {} damage to {}.",
+                            &name.name, damage, &target_name.name
                         ));
                         SufferDamage::new_damage(&mut inflict_damage, wants_melee.target, damage);
                     }
diff --git a/src/visibility_system.rs b/src/visibility_system.rs
index ea1d710..0882472 100644
--- a/src/visibility_system.rs
+++ b/src/visibility_system.rs
@@ -29,7 +29,7 @@ impl<'a> System<'a> for VisibilitySystem {
 
                 // playerなら視界内のタイルを明らかにする
                 let p: Option<&Player> = player.get(ent);
-                if let Some(p) = p {
+                if let Some(_p) = p {
                     for t in map.visible_tiles.iter_mut() {
                         *t = false
                     }
